import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/domain/models/restaurant.dart';
import '../../../../core/domain/models/table_model.dart';
import '../../../../core/domain/models/time_slot.dart';
import '../../../../core/domain/models/food_category.dart';
import '../../../../core/domain/models/location.dart';
import '../../../../core/data/repositories/restaurant_repository.dart';
import '../../../../core/data/repositories/table_repository.dart';
import '../../../../core/services/cloudinary_service.dart';
import '../../../../core/services/location_service.dart';

class RestaurantFormState {
  final bool isLoading;
  final String? error;
  final String? successMessage;

  const RestaurantFormState({
    this.isLoading = false,
    this.error,
    this.successMessage,
  });

  RestaurantFormState copyWith({
    bool? isLoading,
    String? error,
    String? successMessage,
  }) {
    return RestaurantFormState(
      isLoading: isLoading ?? this.isLoading,
      error: error,
      successMessage: successMessage,
    );
  }
}

class RestaurantFormController extends StateNotifier<RestaurantFormState> {
  final RestaurantRepository _restaurantRepository;
  final TableRepository _tableRepository;
  final CloudinaryService _cloudinaryService;
  final LocationService _locationService;

  RestaurantFormController({
    required RestaurantRepository restaurantRepository,
    required TableRepository tableRepository,
    required CloudinaryService cloudinaryService,
    required LocationService locationService,
  }) : _restaurantRepository = restaurantRepository,
       _tableRepository = tableRepository,
       _cloudinaryService = cloudinaryService,
       _locationService = locationService,
       super(const RestaurantFormState());

  Future<String?> createRestaurant({
    required String name,
    required String description,
    required File? imageFile,
    required FoodCategory category,
    required Location location,
    required List<TimeSlot> timeSlots,
    required List<TableModel> tables,
  }) async {
    state = state.copyWith(isLoading: true, error: null);

    try {
      // 1. Upload image to Cloudinary
      String imageUrl = '';
      if (imageFile != null) {
        imageUrl = await _cloudinaryService.uploadImage(
          imageFile,
          folder: 'restaurants',
        );
      }

      // 2. Create restaurant object
      final restaurant = Restaurant(
        id: '', // Will be generated by Firestore
        name: name,
        description: description,
        imageUrl: imageUrl,
        foodCategoryId: category.id,
        foodCategoryName: category.name,
        numberOfTables: tables.length,
        maxSeatsPerTable: 6,
        location: location,
        timeSlots: timeSlots,
      );

      // 3. Save to Firestore
      final restaurantId = await _restaurantRepository.createRestaurant(
        restaurant,
      );

      // 4. Create tables as subcollection (with duplicate prevention)
      final createdTableNumbers = <int>{};
      for (final table in tables) {
        // Skip if we've already created a table with this number
        if (createdTableNumbers.contains(table.tableNumber)) {
          continue;
        }

        try {
          await _tableRepository.createTable(restaurantId, table);
          createdTableNumbers.add(table.tableNumber);
        } catch (e) {
          // If tables write fails due to permissions, don't fail the whole operation
          // Preserve success of restaurant creation and surface a non-blocking message
          // Only set error if it isn't a Firestore permission error pattern
          final msg = e.toString();
          final isPermissionDenied =
              msg.contains('permission-denied') ||
              msg.contains('PERMISSION_DENIED');
          if (!isPermissionDenied) {
            // Unexpected error: record but continue
            state = state.copyWith(error: msg);
          }
        }
      }

      state = state.copyWith(isLoading: false);
      return restaurantId;
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
      return null;
    }
  }

  Future<bool> updateRestaurant({
    required String restaurantId,
    required String name,
    required String description,
    required File? imageFile,
    required String? currentImageUrl,
    required FoodCategory category,
    required Location location,
    required List<TimeSlot> timeSlots,
    required List<TableModel> tables,
  }) async {
    state = state.copyWith(isLoading: true, error: null);

    try {
      // 1. Upload new image if provided
      String imageUrl = currentImageUrl ?? '';
      if (imageFile != null) {
        // Delete old image if exists
        if (currentImageUrl != null && currentImageUrl.isNotEmpty) {
          try {
            final publicId = _cloudinaryService.getPublicIdFromUrl(
              currentImageUrl,
            );
            await _cloudinaryService.deleteImage(publicId);
          } catch (e) {
            // Continue even if deletion fails
          }
        }

        // Upload new image
        imageUrl = await _cloudinaryService.uploadImage(
          imageFile,
          folder: 'restaurants',
        );
      }

      // 2. Update restaurant object
      final restaurant = Restaurant(
        id: restaurantId,
        name: name,
        description: description,
        imageUrl: imageUrl,
        foodCategoryId: category.id,
        foodCategoryName: category.name,
        numberOfTables: tables.length,
        maxSeatsPerTable: 6,
        location: location,
        timeSlots: timeSlots,
      );

      // 3. Update in Firestore
      await _restaurantRepository.updateRestaurant(restaurant);

      // 4. Update tables (delete all and recreate)
      final existingTables = await _tableRepository.getTables(restaurantId);

      for (final table in existingTables) {
        await _tableRepository.deleteTable(restaurantId, table.id);
      }

      for (final table in tables) {
        await _tableRepository.createTable(restaurantId, table);
      }

      state = state.copyWith(
        isLoading: false,
        successMessage: 'Restaurant updated successfully',
      );
      return true;
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
      return false;
    }
  }

  Future<Location?> getCurrentLocation() async {
    try {
      return await _locationService.getCurrentLocation();
    } catch (e) {
      final errorMessage = e.toString().replaceAll('Exception: ', '');
      state = state.copyWith(error: errorMessage);
      return null;
    }
  }

  Future<Location?> getLocationFromAddress(String address) async {
    try {
      return await _locationService.getLocationFromAddress(address);
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }

  void clearError() {
    state = state.copyWith(error: null);
  }

  void clearSuccess() {
    state = state.copyWith(successMessage: null);
  }
}

// Providers
final restaurantFormControllerProvider =
    StateNotifierProvider<RestaurantFormController, RestaurantFormState>((ref) {
      return RestaurantFormController(
        restaurantRepository: RestaurantRepository(),
        tableRepository: TableRepository(),
        cloudinaryService: CloudinaryService(),
        locationService: LocationService(),
      );
    });
